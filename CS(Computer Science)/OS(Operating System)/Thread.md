# Thread

### **💡 What is Thread?**

> **Thread는 Process의 실행의 단위**
> 

🌟 Process vs Thread

- 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위
- 쓰레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위

⇒ Heap, Data, Text 영역은 공유, Stack만 할당 받음, IPC없이도 쓰레드 간 자원의 접근 수정 가능

### 🔎

- **STACK** : 함수 내 지역변수(재선언 및 재할당이 되는)혹은 인자의 메모리 주소가 위치하는 공간, Return Address값을 STACK에 저장한다. 임시 데이터. (stack frame)
- **HEAP** : 동적 메모리 할당(C의 malloc, Node나 JVM의 힙메모리), 코드에서 동적으로 만들어지는 데이터
- **DATA** : 변수의 메모리 영역이 저장되는 공간 (코드에서 함수 선언시에 변수가 가리키는 메모리 공간), 전역변수, 초기화 된 데이터
- **CODE** : 프로그래밍 코드 텍스트가 들어가는 메모리 영역(컴파일 된 결과물)

🥬 **쓰레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있음**

> 스택을 쓰레드마다 독립적으로 할당하는 이유
> 

스택 메모리 공간이 독립적 ⇒ 독립적인 함수 호출이 가능 ⇒ 독립적인 실행 흐름이 가능

> PC Resister를 쓰레드마다 독립적으로 할당하는 이유
> 

쓰레드는 CPU를 할당받았다가 **스케줄러**에 의해 다시 선점당한다.

그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지

기억할 필요가 있다.


### **💡 Multi Thread**

> **멀티 프로세스의 단점을 보완하기 위해 나온것**
> 

- Multi Process
    - 장점: 독립적으로 일을 수행하므로 서로 영향을 끼치지 않는다
    - 단점: Context Switching, IPC에서의 오버헤드가 크다
- **Multi Thread**
    - **장점: 프로세스보다 메모리 사용이 적고, 데이터 통신이 빠르고, 수행속도가 빠름**
    - **단점: 자원 공유 ( Syncronization = 동기화 필요)**

### **💡 User-level Thread vs Kernel-level Thread**

> **User가 생성한 것과 Kernel이 생성한 것으로 구분됨**
> 

1. **Pure user-level**

커널 스레드 1개당 사용자 스레드 n개를 의미 / **1 : n 방식**

이 방식같은 경우에는 커널은 사용자 스레드가 100개가 있어도 전혀 모르기 때문에 사용자 스레드에서 I/O가 하나라도 발생하면 해당 프로세스는 I/O가 풀릴 때 까지 영원히 block ( 병렬성 X )

2. **Pure Kernel-level**

n개의 커널 스레드가 n개의 사용자 스레드를 담당 / **1:1 방식**

1:1 방식이기에 병렬성은 좋으나 효율성 면에서 다소 떨어진다.

3. **Combined**

커널 스레드와 사용자 스레드를 혼합하여 사용하는 방식 ( 위의 두 방식의 장점을 혼합한 방식 )