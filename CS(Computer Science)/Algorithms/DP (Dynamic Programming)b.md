# DP (Dynamic Programming)

## 💡 What is dynamic-programming?

> *복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법*
> 
> 
> *문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 것*
> 



## 💡 동적 계획법을 그래프로 모델화하기

> *동적 계획법은 대부분 그래프, 그 중에서도 **사이클이 없는 유향 그래프(DAG)** 로 모델화*
> 



🌟 **문제로부터 이러한 그래프를 만들어내는 데에만 성공한다면 동적 계획법 문제는 다 푼 것**

### 📌 구성 요소

- **정점** : 문제에서의 특정 상황을 유일하게 결정지을 수 있는 변수들로 이루어진 **상태**
    - 각 정점은 자신의 상태에 대한 답을 변수(배열) *dp*라고 이름짓고,
        
        상태를 구성하는 변수는 순차적으로 배열의 각 차원을 담당
        
        *ex.) 상태를 구성하는 두 변수가 x, y라면  dp[x][y]와 같은 형태로 특정 상태의 답을 표현*
        
- **간선** : 상태간의 전이를 나타내는 **점화식**
    
    > *점화식은 하나의 상태가 결정되기 위해 먼저 결정되어야 하는 다른 상태들과의 관계를 나타내는 식*
    > 
    - *ex.) $dp[x] = max(dp[x-1], dp[x-2])$ 라는 식은 점화식이 될 수 있고, 여기서  $dp[x]$ 가 결정되기 전에 먼저 결정 되어야 하는 상태는*
        
        $dp[x-1],dp[x-2]$ *두가지가 있음*
        

### ①——②——③

**정점(vertice) :** 노드(node)라고도 하며 정점에는 데이터가 저장됩니다. (1, 2, 3)

**간선(edge) :** 링크(arcs)라고도 하며 노드간의 관계를 나타냅니다.

🌟 **동적 계획법에서 가장 어려운 것이 아마도 이 정점을 표현하기 위한 변수를 설정하는 일**

✅ 변수를 너무 많이 사용하면 상태의 수가 불필요하게 많아져 효율이 나빠질 수 있기 때문에 *최소한의 상태와 최소한의 점화식* 을 사용하여 표현

### 📌 그래프의 조건

> *기본적으로* 사이클이 없어야 함, ( 특정 상태에서 다른 상태로 도달한 후 다시 원래의 상태로 되돌아오는 방법이 존재하지 않아야 함 )
> 

**🌟 점화식을 만들 때에는 그래프가 항상 DAG 형태가 되는지를 생각해 보아야 함**

- **변수가 항상 감소 / 항상 증가하는 상태에서만 가져오는 경우**
    
    *ex.) $dp[i] = max_{1<j<i}dp[j] + C[i]$*
    
    $j < i$ 인 $j$ 들로부터만 상태에 대한 답을 가져오므로 사이클이 형성되지 않음
    
- **변수들의 합 / 차가 항상 감소 / 항상 증가하는 상태에서만 가져오는 경우**
    
    ex.) $dp[s][e] = max(dp[s+1][e], dp[s][e-1]) + C[s][e]$
    
    범위를 변수로 가지는 경우에 자주 사용
    
    ⇒ $[s,e]$ 의 범위는 항상 $[s+1, e]$ 와 $[s, e-1]$ 의 범위보다 크기 때문에 사이클이 형성되지 않음
    

### 📌 시간 복잡도

> *(top-down), (bottom-up) 방식 모두 정점의 개수가 $V$ 이고 간선의 개수가 $E$ 일 때 $O(V+E)$ 의 시간이 소요*
> 

## 💡 Example



### 📌 1로 만들기

> [*https://www.acmicpc.net/problem/1463*](https://www.acmicpc.net/problem/1463)
> 

문제에서의 상태는 dp[x]: x를 1로 만들기 위해 필요한 최소의 연산 횟수

답 = dp[N]

- 수식으로 표현
    
    ![Untitled](https://user-images.githubusercontent.com/63443366/136696163-f64d0948-2c38-4c9b-b688-96203e377dc1.png)
    
    ✅ **(DAG)** x > 1인 모든 경우에, dp[x]를 경정하기 위해 먼저 결정되어야 하는
    
    상태들인 x-1, x/2, x/3는 모두 x보다 항상 작기 때문에 방향이 고정, 사이클이 형성되지 않는다.
    
    ✅ **(시간 복잡도)** 상태의 개수가 N, 점화식이 많아야 3개이므로 O[N]
    

- Code (Bottom-up)
    
    ```java
         public static void main(String[] args) {
     
            Scanner sc = new Scanner(System.in);
     
            int n = sc.nextInt();
            int[] dp = new int[n + 1];
    				dp[0] = 0;
            dp[1] = 0;
     
            for (int i = 2; i < n + 1; i++) {
    					dp[i] = dp[i-1]+1;
    					if(i%2 == 0)
    						dp[i] = Math.min(dp[i/2]+1, dp[i]);
    					if(i%3 == 0)
    						dp[i] = Math.min(dp[i/3]+1, dp[i]);
    				}
            System.out.println(dp[n]);
        }
    ```