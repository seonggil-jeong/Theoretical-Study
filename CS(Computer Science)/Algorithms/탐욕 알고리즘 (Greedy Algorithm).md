# 탐욕 알고리즘 (Greedy Algorithm)

## 💡 What is greedy-algorithm?

> ***여러 경우 중 하나를 결정해야할 때마다, 매순간 최적이라고 생각되는 경우를 선택하는 방식으로 진행해서,***
> 
> 
> ***최종적인 값을 구하는 방식***
> 

### 📌 특징

> **순간 최적 선택한 결과가 전체 문제의 최적이라는 보장은 없다**
> 
> 
> **현재의 선택이 앞으로 남은 선택에 어떤 영향을 끼칠지는 고려하지 않는다**
> 

### 📌 어떤 경우에 잘 동작하는가?

> **탐욕 선택 속성(greedy choice property), 최적 부분 구조(optimal substructure)**
> 
> 
> **특성을 가지는 문제들을 해결하는데 강점**
> 

✅ **greedy choice property**

**탐욕적으로만 선택을 해도 최적해를 구할 수 있다는 의미** *( 전체 문제의 최적해가 아닌 현재까지의 )*

즉, 일단 현재 순간의 최적을 한번 선택하면, 이를 번복하지 않는다. *( 선택한 것을 버리고 다른 것을 취하지 않는다 )*

✅ **optimal substructure**

‘**전체 문제의 최적해**가 각 **부분 문제들의 최적해**로 이루어진 경우’ 이 속성을 만족하면

'최적 부분 구조를 갖는다'라고 한다.

반대로, 부분 문제들의 최적해만으로 **전체 최적해를 얻을 수 없는 경우** '최적 부분 구조를 갖지 않는다'라고 한다.

*ex) 최적 부분 구조를 갖지 않는 경우*

- **첫 번쨰 선택을 하고 나서 남는 부분 문제는 최적이 아닌 방법으로  풀어야 하는 경우**

🌟 **한번의 선택이 다음 선택에는 전혀 무관한 값이여야 하며, 매 순간의 최적해가 문제에 대한 최적해여야 한다는 의미**

### 📌 왜 Greedy Algorithm을 사용하는가?

> **빠르다, 적당히 괜찮은 답을 구할 수 있다**
> 
- **탐욕 알고리즘을 사용해도** **항상 최적의 해를 구할 수 있는 경우**, DP보다 수행 시간이 훨씬 빠르다

- **시간이나 공간적 제약**으로 인해 최적해를 찾기 어렵다면 **적당히 괜찮은 답을 찾는 것으로 타협**
    
    ✅ 이때, 임의의 답 보다는 더 괜찮은 답으로 사용될 수 있다
    

✅ 보통 프로그래밍 대회에서는 첫 번째 용도로만 사용

두 번째 용도로 사용할 때 현실적이 근사값을 찾기 위한 방법으로 휴리스틱(heuristic)기법 등을 사용

🌟 휴리스틱(heuristic) : *'경험에 의거한' 문제 풀이 기법으로, '대충 어림 짐작해서 풀기’*

## 💡 탐욕 알고리즘(Greedy Algorithm) vs 동적 계획법(Dynamic Programming)

> ***Greedy Algorithm vs Dynamic Programming***
> 

### 📌 **Greedy Algorithm**

> **빠른 성능, 항상 최적의 해를 보장하지 않는다, 선택을 번복하지 않는다.**
> 
- 한번 선택하고 나면 번복하지 않는다 (그 순간의 최적을 선택)
- 항상 최적해를 보장하지는 않는다 (정당성 증명 과정을 반드시 거쳐야 함)
- 대게 동적 계획법보다 더 빠른 성능 보임

### 📌 **Dynamic Programming**

> 
> 

✅ 가상화, 자동화와 같은 클라우드 관련 기술의 활용으로 시스템의 성능과 비용이 최적화

⇒ 유연한 사용자 정의가 가능

- 전체 단계를 마치고, 최적해를 찾기 위해 재고하는 단계를 거친다.
- 항상 최적해를 보장한다.

### 📌 탐욕 알고리즘 문제 풀이

> 
> 
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다
2. 각 조각마다 어떤 우선순위로 선택할지 결정
3. 두 가지 속성 증명 (greedy choice property, optimal substructure)
